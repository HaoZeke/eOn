/*
** This file is part of eOn.
**
** SPDX-License-Identifier: BSD-3-Clause
**
** Copyright (c) 2010--present, eOn Development Team
** All rights reserved.
**
** Repo:
** https://github.com/TheochemUI/eOn
*/

#include "client/io/ConWriter.hpp"
#include "Element.hpp"
#include "client/IOHelpers.hpp"
#include <iostream>

namespace eonc::io {

/**
 * @brief Writes the Matter object to a .con file.
 *
 * This function writes the details of the Matter object, such as atomic
 * positions, cell dimensions, and atomic types, to a .con file. The file format
 * is consistent with eOn-generated files.
 *
 * @param mat The Matter object containing atomic data.
 * @param fout The output file stream where the data will be written.
 * @return True if the file is written successfully, false otherwise.
 *
 * @note The function assumes that atoms are grouped by their atomic numbers.
 *       If the Matter object is empty (i.e., contains no atoms), the function
 *       returns false.
 *       The function uses unique masses and atomic numbers while preserving the
 *       order of their first occurrences.
 */
bool ConWriter::writeImpl(const Matter &mat, std::ofstream &fout) {
  // TODO(rg) :: These should be lambda applied sometime
  // if (mat.usePeriodicBoundaries) {
  //     mat.applyPeriodicBoundary();
  // }

  // Headers to be written at the beginning of the file
  const std::vector<std::string> preHeader{"Generated by eOn\n", "\n"};
  const std::vector<std::string> postHeader{"\n", "\n"};
  const size_t numAtoms = mat.numberOfAtoms();
  // Early return for empty objects
  if (numAtoms == 0) {
    return false;
  }

  // Get unique masses and atomic numbers, preserving order
  const auto uniq_masses = getUniqueValues(mat.getMasses());
  const auto uqc_atmnrs = getUniqueCounts(mat.getAtomicNrs());
  const size_t numComponents = uniq_masses.size();

  // Initialize component start indices
  // This vector will store the starting index of each component
  std::vector<size_t> csidxs;
  // Reserve enough space to prevent reallocations
  csidxs.reserve(numComponents + 1);
  csidxs.push_back(0);

  // Iterate over atoms, starting from 1, to determine the starting index of
  // each new component
  for (size_t idx = 1; idx < numAtoms; ++idx) {
    if (mat.getAtomicNr(idx) != mat.getAtomicNr(idx - 1)) {
      csidxs.push_back(idx);
    }
  }

  // Add the total number of atoms as the last index to mark the end of the last
  // component
  csidxs.push_back(numAtoms);

  // Write pre-defined headers
  fout << fmt::format("{}", fmt::join(preHeader, ""));

  // Write cell lengths
  Eigen::Vector3d lengths = mat.cell.rowwise().norm();
  fout << fmt::format("{:.6f}\n", fmt::join(lengths, " "));

  // Calculate and write cell angles
  Eigen::Vector3d angles;
  angles(0) = std::acos(mat.cell.row(0).dot(mat.cell.row(1)) /
                        (lengths(0) * lengths(1))) *
              180 / M_PI;
  angles(1) = std::acos(mat.cell.row(0).dot(mat.cell.row(2)) /
                        (lengths(0) * lengths(2))) *
              180 / M_PI;
  angles(2) = std::acos(mat.cell.row(1).dot(mat.cell.row(2)) /
                        (lengths(1) * lengths(2))) *
              180 / M_PI;
  fout << fmt::format("{:.6f}\n", fmt::join(angles, " "));

  // Write post-header
  fout << fmt::format("{}", fmt::join(postHeader, ""));

  // Write the number of components
  fout << numComponents << "\n";

  // Write the count of atoms for each component
  fout << fmt::format("{}\n", fmt::join(uqc_atmnrs, " "));
  // Write the unique masses of each component
  fout << fmt::format("{:.6f}\n", fmt::join(uniq_masses, " "));

  // Write atomic symbols and coordinates for each component
  for (size_t jdx = 0; jdx < numComponents; ++jdx) {
    fout << mass2atom(uniq_masses[jdx]) << "\n";
    fout << fmt::format("Coordinates of component{:4}\n", jdx + 1);

    for (size_t i = csidxs[jdx]; i < csidxs[jdx + 1]; ++i) {
      fout << fmt::format("{:.6f} {:.6f} {:.6f} {} {}", mat.getPosition(i, 0),
                          mat.getPosition(i, 1), mat.getPosition(i, 2),
                          mat.getFixed(i), i + 1);
      if (jdx < numComponents - 1) {
        fout << "\n";
      }
    }
  }

  return true;
}

} // namespace eonc::io
